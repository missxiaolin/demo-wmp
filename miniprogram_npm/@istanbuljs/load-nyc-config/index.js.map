{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst fs = require('fs');\nconst path = require('path');\nconst {promisify} = require('util');\nconst camelcase = require('camelcase');\nconst findUp = require('find-up');\nconst resolveFrom = require('resolve-from');\nconst getPackageType = require('get-package-type');\n\nconst readFile = promisify(fs.readFile);\n\nlet loadActive = false;\n\nfunction isLoading() {\n\treturn loadActive;\n}\n\nconst standardConfigFiles = [\n\t'.nycrc',\n\t'.nycrc.json',\n\t'.nycrc.yml',\n\t'.nycrc.yaml',\n\t'nyc.config.js',\n\t'nyc.config.cjs',\n\t'nyc.config.mjs'\n];\n\nfunction camelcasedConfig(config) {\n\tconst results = {};\n\tfor (const [field, value] of Object.entries(config)) {\n\t\tresults[camelcase(field)] = value;\n\t}\n\n\treturn results;\n}\n\nasync function findPackage(options) {\n\tconst cwd = options.cwd || process.env.NYC_CWD || process.cwd();\n\tconst pkgPath = await findUp('package.json', {cwd});\n\tif (pkgPath) {\n\t\tconst pkgConfig = JSON.parse(await readFile(pkgPath, 'utf8')).nyc || {};\n\t\tif ('cwd' in pkgConfig) {\n\t\t\tpkgConfig.cwd = path.resolve(path.dirname(pkgPath), pkgConfig.cwd);\n\t\t}\n\n\t\treturn {\n\t\t\tcwd: path.dirname(pkgPath),\n\t\t\tpkgConfig\n\t\t};\n\t}\n\n\treturn {\n\t\tcwd,\n\t\tpkgConfig: {}\n\t};\n}\n\nasync function actualLoad(configFile) {\n\tif (!configFile) {\n\t\treturn {};\n\t}\n\n\tconst configExt = path.extname(configFile).toLowerCase();\n\tswitch (configExt) {\n\t\tcase '.js':\n\t\t\t/* istanbul ignore next: coverage for 13.2.0+ is shown in load-esm.js */\n\t\t\tif (await getPackageType(configFile) === 'module') {\n\t\t\t\treturn require('./load-esm')(configFile);\n\t\t\t}\n\n\t\t\t/* fallthrough */\n\t\tcase '.cjs':\n\t\t\treturn require(configFile);\n\t\t/* istanbul ignore next: coverage for 13.2.0+ is shown in load-esm.js */\n\t\tcase '.mjs':\n\t\t\treturn require('./load-esm')(configFile);\n\t\tcase '.yml':\n\t\tcase '.yaml':\n\t\t\treturn require('js-yaml').load(await readFile(configFile, 'utf8'));\n\t\tdefault:\n\t\t\treturn JSON.parse(await readFile(configFile, 'utf8'));\n\t}\n}\n\nasync function loadFile(configFile) {\n\t/* This lets @istanbuljs/esm-loader-hook avoid circular initialization when loading\n\t * configuration.  This should generally only happen when the loader hook is active\n\t * on the main nyc process. */\n\tloadActive = true;\n\n\ttry {\n\t\treturn await actualLoad(configFile);\n\t} finally {\n\t\tloadActive = false;\n\t}\n}\n\nasync function applyExtends(config, filename, loopCheck = new Set()) {\n\tconfig = camelcasedConfig(config);\n\tif ('extends' in config) {\n\t\tconst extConfigs = [].concat(config.extends);\n\t\tif (extConfigs.some(e => typeof e !== 'string')) {\n\t\t\tthrow new TypeError(`${filename} contains an invalid 'extends' option`);\n\t\t}\n\n\t\tdelete config.extends;\n\t\tconst filePath = path.dirname(filename);\n\t\tfor (const extConfig of extConfigs) {\n\t\t\tconst configFile = resolveFrom.silent(filePath, extConfig) ||\n\t\t\t\tresolveFrom.silent(filePath, './' + extConfig);\n\t\t\tif (!configFile) {\n\t\t\t\tthrow new Error(`Could not resolve configuration file ${extConfig} from ${path.dirname(filename)}.`);\n\t\t\t}\n\n\t\t\tif (loopCheck.has(configFile)) {\n\t\t\t\tthrow new Error(`Circular extended configurations: '${configFile}'.`);\n\t\t\t}\n\n\t\t\tloopCheck.add(configFile);\n\n\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\tconst configLoaded = await loadFile(configFile);\n\t\t\tif ('cwd' in configLoaded) {\n\t\t\t\tconfigLoaded.cwd = path.resolve(path.dirname(configFile), configLoaded.cwd);\n\t\t\t}\n\n\t\t\tObject.assign(\n\t\t\t\tconfig,\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tawait applyExtends(configLoaded, configFile, loopCheck)\n\t\t\t);\n\t\t}\n\t}\n\n\treturn config;\n}\n\nasync function loadNycConfig(options = {}) {\n\tconst {cwd, pkgConfig} = await findPackage(options);\n\tconst configFiles = [].concat(options.nycrcPath || standardConfigFiles);\n\tconst configFile = await findUp(configFiles, {cwd});\n\tif (options.nycrcPath && !configFile) {\n\t\tthrow new Error(`Requested configuration file ${options.nycrcPath} not found`);\n\t}\n\n\tconst config = {\n\t\tcwd,\n\t\t...(await applyExtends(pkgConfig, path.join(cwd, 'package.json'))),\n\t\t...(await applyExtends(await loadFile(configFile), configFile))\n\t};\n\n\tconst arrayFields = ['require', 'extension', 'exclude', 'include'];\n\tfor (const arrayField of arrayFields) {\n\t\tif (config[arrayField]) {\n\t\t\tconfig[arrayField] = [].concat(config[arrayField]);\n\t\t}\n\t}\n\n\treturn config;\n}\n\nmodule.exports = {\n\tloadNycConfig,\n\tisLoading\n};\n"]}