{"version":3,"sources":["index.js","default-exclude.js","default-extension.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst defaultExclude = require('./default-exclude.js');\nconst defaultExtension = require('./default-extension.js');\n\nconst nycCommands = {\n\tall: [null, 'check-coverage', 'instrument', 'merge', 'report'],\n\ttestExclude: [null, 'instrument', 'report', 'check-coverage'],\n\tinstrument: [null, 'instrument'],\n\tcheckCoverage: [null, 'report', 'check-coverage'],\n\treport: [null, 'report'],\n\tmain: [null],\n\tinstrumentOnly: ['instrument']\n};\n\nconst cwd = {\n\tdescription: 'working directory used when resolving paths',\n\ttype: 'string',\n\tget default() {\n\t\treturn process.cwd();\n\t},\n\tnycCommands: nycCommands.all\n};\n\nconst nycrcPath = {\n\tdescription: 'specify an explicit path to find nyc configuration',\n\tnycCommands: nycCommands.all\n};\n\nconst tempDir = {\n\tdescription: 'directory to output raw coverage information to',\n\ttype: 'string',\n\tdefault: './.nyc_output',\n\tnycAlias: 't',\n\tnycHiddenAlias: 'temp-directory',\n\tnycCommands: [null, 'check-coverage', 'merge', 'report']\n};\n\nconst testExclude = {\n\texclude: {\n\t\tdescription: 'a list of specific files and directories that should be excluded from coverage, glob patterns are supported',\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'string'\n\t\t},\n\t\tdefault: defaultExclude,\n\t\tnycCommands: nycCommands.testExclude,\n\t\tnycAlias: 'x'\n\t},\n\texcludeNodeModules: {\n\t\tdescription: 'whether or not to exclude all node_module folders (i.e. **/node_modules/**) by default',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.testExclude\n\t},\n\tinclude: {\n\t\tdescription: 'a list of specific files that should be covered, glob patterns are supported',\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'string'\n\t\t},\n\t\tdefault: [],\n\t\tnycCommands: nycCommands.testExclude,\n\t\tnycAlias: 'n'\n\t},\n\textension: {\n\t\tdescription: 'a list of extensions that nyc should handle in addition to .js',\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'string'\n\t\t},\n\t\tdefault: defaultExtension,\n\t\tnycCommands: nycCommands.testExclude,\n\t\tnycAlias: 'e'\n\t}\n};\n\nconst instrumentVisitor = {\n\tcoverageVariable: {\n\t\tdescription: 'variable to store coverage',\n\t\ttype: 'string',\n\t\tdefault: '__coverage__',\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tcoverageGlobalScope: {\n\t\tdescription: 'scope to store the coverage variable',\n\t\ttype: 'string',\n\t\tdefault: 'this',\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tcoverageGlobalScopeFunc: {\n\t\tdescription: 'avoid potentially replaced `Function` when finding global scope',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tignoreClassMethods: {\n\t\tdescription: 'class method names to ignore for coverage',\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'string'\n\t\t},\n\t\tdefault: [],\n\t\tnycCommands: nycCommands.instrument\n\t}\n};\n\nconst instrumentParseGen = {\n\tautoWrap: {\n\t\tdescription: 'allow `return` statements outside of functions',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tesModules: {\n\t\tdescription: 'should files be treated as ES Modules',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tparserPlugins: {\n\t\tdescription: 'babel parser plugins to use when parsing the source',\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'string'\n\t\t},\n\t\t/* Babel parser plugins are to be enabled when the feature is stage 3 and\n\t\t * implemented in a released version of node.js. */\n\t\tdefault: [\n\t\t\t'asyncGenerators',\n\t\t\t'bigInt',\n\t\t\t'classProperties',\n\t\t\t'classPrivateProperties',\n\t\t\t'classPrivateMethods',\n\t\t\t'dynamicImport',\n\t\t\t'importMeta',\n\t\t\t'numericSeparator',\n\t\t\t'objectRestSpread',\n\t\t\t'optionalCatchBinding',\n\t\t\t'topLevelAwait'\n\t\t],\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tcompact: {\n\t\tdescription: 'should the output be compacted?',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tpreserveComments: {\n\t\tdescription: 'should comments be preserved in the output?',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.instrument\n\t},\n\tproduceSourceMap: {\n\t\tdescription: 'should source maps be produced?',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.instrument\n\t}\n};\n\nconst checkCoverage = {\n\texcludeAfterRemap: {\n\t\tdescription: 'should exclude logic be performed after the source-map remaps filenames?',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.checkCoverage\n\t},\n\tbranches: {\n\t\tdescription: 'what % of branches must be covered?',\n\t\ttype: 'number',\n\t\tdefault: 0,\n\t\tminimum: 0,\n\t\tmaximum: 100,\n\t\tnycCommands: nycCommands.checkCoverage\n\t},\n\tfunctions: {\n\t\tdescription: 'what % of functions must be covered?',\n\t\ttype: 'number',\n\t\tdefault: 0,\n\t\tminimum: 0,\n\t\tmaximum: 100,\n\t\tnycCommands: nycCommands.checkCoverage\n\t},\n\tlines: {\n\t\tdescription: 'what % of lines must be covered?',\n\t\ttype: 'number',\n\t\tdefault: 90,\n\t\tminimum: 0,\n\t\tmaximum: 100,\n\t\tnycCommands: nycCommands.checkCoverage\n\t},\n\tstatements: {\n\t\tdescription: 'what % of statements must be covered?',\n\t\ttype: 'number',\n\t\tdefault: 0,\n\t\tminimum: 0,\n\t\tmaximum: 100,\n\t\tnycCommands: nycCommands.checkCoverage\n\t},\n\tperFile: {\n\t\tdescription: 'check thresholds per file',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.checkCoverage\n\t}\n};\n\nconst report = {\n\tcheckCoverage: {\n\t\tdescription: 'check whether coverage is within thresholds provided',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.report\n\t},\n\treporter: {\n\t\tdescription: 'coverage reporter(s) to use',\n\t\ttype: 'array',\n\t\titems: {\n\t\t\ttype: 'string'\n\t\t},\n\t\tdefault: ['text'],\n\t\tnycCommands: nycCommands.report,\n\t\tnycAlias: 'r'\n\t},\n\treportDir: {\n\t\tdescription: 'directory to output coverage reports in',\n\t\ttype: 'string',\n\t\tdefault: 'coverage',\n\t\tnycCommands: nycCommands.report\n\t},\n\tshowProcessTree: {\n\t\tdescription: 'display the tree of spawned processes',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.report\n\t},\n\tskipEmpty: {\n\t\tdescription: 'don\\'t show empty files (no lines of code) in report',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.report\n\t},\n\tskipFull: {\n\t\tdescription: 'don\\'t show files with 100% statement, branch, and function coverage',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.report\n\t}\n};\n\nconst nycMain = {\n\tsilent: {\n\t\tdescription: 'don\\'t output a report after tests finish running',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.main,\n\t\tnycAlias: 's'\n\t},\n\tall: {\n\t\tdescription: 'whether or not to instrument all files of the project (not just the ones touched by your test suite)',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.main,\n\t\tnycAlias: 'a'\n\t},\n\teager: {\n\t\tdescription: 'instantiate the instrumenter at startup (see https://git.io/vMKZ9)',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.main\n\t},\n\tcache: {\n\t\tdescription: 'cache instrumentation results for improved performance',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.main,\n\t\tnycAlias: 'c'\n\t},\n\tcacheDir: {\n\t\tdescription: 'explicitly set location for instrumentation cache',\n\t\ttype: 'string',\n\t\tnycCommands: nycCommands.main\n\t},\n\tbabelCache: {\n\t\tdescription: 'cache babel transpilation results for improved performance',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.main\n\t},\n\tuseSpawnWrap: {\n\t\tdescription: 'use spawn-wrap instead of setting process.env.NODE_OPTIONS',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.main\n\t},\n\thookRequire: {\n\t\tdescription: 'should nyc wrap require?',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.main\n\t},\n\thookRunInContext: {\n\t\tdescription: 'should nyc wrap vm.runInContext?',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.main\n\t},\n\thookRunInThisContext: {\n\t\tdescription: 'should nyc wrap vm.runInThisContext?',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.main\n\t},\n\tclean: {\n\t\tdescription: 'should the .nyc_output folder be cleaned before executing tests',\n\t\ttype: 'boolean',\n\t\tdefault: true,\n\t\tnycCommands: nycCommands.main\n\t}\n};\n\nconst instrumentOnly = {\n\tinPlace: {\n\t\tdescription: 'should nyc run the instrumentation in place?',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.instrumentOnly\n\t},\n\texitOnError: {\n\t\tdescription: 'should nyc exit when an instrumentation failure occurs?',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.instrumentOnly\n\t},\n\tdelete: {\n\t\tdescription: 'should the output folder be deleted before instrumenting files?',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.instrumentOnly\n\t},\n\tcompleteCopy: {\n\t\tdescription: 'should nyc copy all files from input to output as well as instrumented files?',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tnycCommands: nycCommands.instrumentOnly\n\t}\n};\n\nconst nyc = {\n\tdescription: 'nyc configuration options',\n\ttype: 'object',\n\tproperties: {\n\t\tcwd,\n\t\tnycrcPath,\n\t\ttempDir,\n\n\t\t/* Test Exclude */\n\t\t...testExclude,\n\n\t\t/* Instrumentation settings */\n\t\t...instrumentVisitor,\n\n\t\t/* Instrumentation parser/generator settings */\n\t\t...instrumentParseGen,\n\t\tsourceMap: {\n\t\t\tdescription: 'should nyc detect and handle source maps?',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: true,\n\t\t\tnycCommands: nycCommands.instrument\n\t\t},\n\t\trequire: {\n\t\t\tdescription: 'a list of additional modules that nyc should attempt to require in its subprocess, e.g., @babel/register, @babel/polyfill',\n\t\t\ttype: 'array',\n\t\t\titems: {\n\t\t\t\ttype: 'string'\n\t\t\t},\n\t\t\tdefault: [],\n\t\t\tnycCommands: nycCommands.instrument,\n\t\t\tnycAlias: 'i'\n\t\t},\n\t\tinstrument: {\n\t\t\tdescription: 'should nyc handle instrumentation?',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: true,\n\t\t\tnycCommands: nycCommands.instrument\n\t\t},\n\n\t\t/* Check coverage */\n\t\t...checkCoverage,\n\n\t\t/* Report options */\n\t\t...report,\n\n\t\t/* Main command options */\n\t\t...nycMain,\n\n\t\t/* Instrument command options */\n\t\t...instrumentOnly\n\t}\n};\n\nconst configs = {\n\tnyc,\n\ttestExclude: {\n\t\tdescription: 'test-exclude options',\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tcwd,\n\t\t\t...testExclude\n\t\t}\n\t},\n\tbabelPluginIstanbul: {\n\t\tdescription: 'babel-plugin-istanbul options',\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tcwd,\n\t\t\t...testExclude,\n\t\t\t...instrumentVisitor\n\t\t}\n\t},\n\tinstrumentVisitor: {\n\t\tdescription: 'instrument visitor options',\n\t\ttype: 'object',\n\t\tproperties: instrumentVisitor\n\t},\n\tinstrumenter: {\n\t\tdescription: 'stand-alone instrumenter options',\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\t...instrumentVisitor,\n\t\t\t...instrumentParseGen\n\t\t}\n\t}\n};\n\nfunction defaultsReducer(defaults, [name, {default: value}]) {\n\t/* Modifying arrays in defaults is safe, does not change schema. */\n\tif (Array.isArray(value)) {\n\t\tvalue = [...value];\n\t}\n\n\treturn Object.assign(defaults, {[name]: value});\n}\n\nmodule.exports = {\n\t...configs,\n\tdefaults: Object.keys(configs).reduce(\n\t\t(defaults, id) => {\n\t\t\tObject.defineProperty(defaults, id, {\n\t\t\t\tenumerable: true,\n\t\t\t\tget() {\n\t\t\t\t\t/* This defers `process.cwd()` until defaults are requested. */\n\t\t\t\t\treturn Object.entries(configs[id].properties)\n\t\t\t\t\t\t.filter(([, info]) => 'default' in info)\n\t\t\t\t\t\t.reduce(defaultsReducer, {});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn defaults;\n\t\t},\n\t\t{}\n\t)\n};\n","\n\nconst defaultExtension = require('./default-extension.js');\nconst testFileExtensions = defaultExtension\n\t.map(extension => extension.slice(1))\n\t.join(',');\n\nmodule.exports = [\n\t'coverage/**',\n\t'packages/*/test{,s}/**',\n\t'**/*.d.ts',\n\t'test{,s}/**',\n\t`test{,-*}.{${testFileExtensions}}`,\n\t`**/*{.,-}test.{${testFileExtensions}}`,\n\t'**/__tests__/**',\n\n\t/* Exclude common development tool configuration files */\n\t'**/{ava,babel,nyc}.config.{js,cjs,mjs}',\n\t'**/jest.config.{js,cjs,mjs,ts}',\n\t'**/{karma,rollup,webpack}.config.js',\n\t'**/.{eslint,mocha}rc.{js,cjs}'\n];\n","\n\nmodule.exports = [\n\t'.js',\n\t'.cjs',\n\t'.mjs',\n\t'.ts',\n\t'.tsx',\n\t'.jsx'\n];\n"]}