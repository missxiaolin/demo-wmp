{"version":3,"sources":["index.js","source-map.js","printer.js","buffer.js","node/index.js","node/whitespace.js","node/parentheses.js","generators/index.js","generators/template-literals.js","generators/expressions.js","generators/statements.js","generators/classes.js","generators/methods.js","generators/modules.js","generators/types.js","generators/flow.js","generators/base.js","generators/jsx.js","generators/typescript.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AIZA,AFMA,ADGA;AELA,AHSA,AIZA,AFMA,ADGA;AELA,AHSA,AIZA,AFMA,ADGA;AELA,AHSA,AIZA,ACHA,AHSA,ADGA;AELA,AHSA,AIZA,ACHA,AHSA,ADGA;AELA,AHSA,AIZA,ACHA,AHSA,ADGA;AELA,AHSA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AHSA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AHSA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,APqBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,APqBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,APqBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,AFMA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,AFMA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,AFMA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AMlBA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AMlBA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AHSA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AZoCA,AJYA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGenerator = void 0;\nexports.default = generate;\nvar _sourceMap = require(\"./source-map\");\nvar _printer = require(\"./printer\");\nclass Generator extends _printer.default {\n  constructor(ast, opts = {}, code) {\n    const format = normalizeOptions(code, opts);\n    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n    super(format, map);\n    this.ast = void 0;\n    this.ast = ast;\n  }\n  generate() {\n    return super.generate(this.ast);\n  }\n}\nfunction normalizeOptions(code, opts) {\n  const format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \"\n    },\n    jsescOption: Object.assign({\n      quotes: \"double\",\n      wrap: true,\n      minimal: false\n    }, opts.jsescOption),\n    recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,\n    topicToken: opts.topicToken\n  };\n  {\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n  }\n  if (format.minified) {\n    format.compact = true;\n    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.includes(\"@license\") || value.includes(\"@preserve\"));\n  }\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500000;\n    if (format.compact) {\n      console.error(\"[BABEL] Note: The code generator has deoptimised the styling of \" + `${opts.filename} as it exceeds the max of ${\"500KB\"}.`);\n    }\n  }\n  if (format.compact) {\n    format.indent.adjustMultilineComment = false;\n  }\n  const {\n    auxiliaryCommentBefore,\n    auxiliaryCommentAfter,\n    shouldPrintComment\n  } = format;\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n  return format;\n}\nclass CodeGenerator {\n  constructor(ast, opts, code) {\n    this._generator = void 0;\n    this._generator = new Generator(ast, opts, code);\n  }\n  generate() {\n    return this._generator.generate();\n  }\n}\nexports.CodeGenerator = CodeGenerator;\nfunction generate(ast, opts, code) {\n  const gen = new Generator(ast, opts, code);\n  return gen.generate();\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _genMapping = require(\"@jridgewell/gen-mapping\");\nvar _traceMapping = require(\"@jridgewell/trace-mapping\");\nclass SourceMap {\n  constructor(opts, code) {\n    var _opts$sourceFileName;\n    this._map = void 0;\n    this._rawMappings = void 0;\n    this._sourceFileName = void 0;\n    this._lastGenLine = 0;\n    this._lastSourceLine = 0;\n    this._lastSourceColumn = 0;\n    this._inputMap = void 0;\n    const map = this._map = new _genMapping.GenMapping({\n      sourceRoot: opts.sourceRoot\n    });\n    this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n    if (opts.inputSourceMap) {\n      this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          var _this$_inputMap$sourc;\n          (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);\n        }\n      }\n    }\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\\\/g, \"/\"), code[sourceFileName]);\n      }\n    }\n  }\n  get() {\n    return (0, _genMapping.toEncodedMap)(this._map);\n  }\n  getDecoded() {\n    return (0, _genMapping.toDecodedMap)(this._map);\n  }\n  getRawMappings() {\n    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));\n  }\n  mark(generated, line, column, identifierName, identifierNamePos, filename) {\n    var _originalMapping;\n    this._rawMappings = undefined;\n    let originalMapping;\n    if (line != null) {\n      if (this._inputMap) {\n        originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {\n          line,\n          column\n        });\n        if (!originalMapping.name && identifierNamePos) {\n          const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: (filename == null ? void 0 : filename.replace(/\\\\/g, \"/\")) || this._sourceFileName,\n          line: line,\n          column: column\n        };\n      }\n    }\n    (0, _genMapping.maybeAddMapping)(this._map, {\n      name: identifierName,\n      generated,\n      source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,\n      original: originalMapping\n    });\n  }\n}\nexports.default = SourceMap;\n\n//# sourceMappingURL=source-map.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _buffer = require(\"./buffer\");\nvar n = require(\"./node\");\nvar _t = require(\"@babel/types\");\nvar generatorFunctions = require(\"./generators\");\nrequire(\"@jridgewell/trace-mapping\");\nconst {\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration\n} = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_BlOCK_COMMENT_END = /\\*\\//;\nconst {\n  needsParens\n} = n;\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._indentChar = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this._lastCommentLine = 0;\n    this._endsWithInnerRaw = false;\n    this._indentInnerComments = true;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n    this._inputMap = map == null ? void 0 : map._inputMap;\n  }\n  generate(ast) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n    return this._buf.get();\n  }\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(59);\n    } else {\n      this._queue(59);\n    }\n    this._noLineTerminator = false;\n  }\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.tokenChar(125);\n  }\n  space(force = false) {\n    if (this.format.compact) return;\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n  word(str, noLineTerminatorAfter = false) {\n    this._maybePrintInnerComments();\n    if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, false);\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n  token(str, maybeNewline = false) {\n    this._maybePrintInnerComments();\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (lastChar === 33 && str === \"--\" || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n  tokenChar(char) {\n    this._maybePrintInnerComments();\n    const lastChar = this.getLastChar();\n    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n  newline(i = 1, force) {\n    if (i <= 0) return;\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n    if (i > 2) i = 2;\n    i -= this._buf.getNewlineCount();\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n    return;\n  }\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n  exactSource(loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp(\"start\", loc);\n    this._buf.exactSource(loc, cb);\n  }\n  source(prop, loc) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.source(prop, loc);\n  }\n  sourceWithOffset(prop, loc, lineOffset, columnOffset) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset);\n  }\n  withSource(prop, loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp(prop, loc);\n    this._buf.withSource(prop, loc, cb);\n  }\n  sourceIdentifierName(identifierName, pos) {\n    if (!this._buf._canMarkIdName) return;\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n  _space() {\n    this._queue(32);\n  }\n  _newline() {\n    this._queue(10);\n  }\n  _append(str, maybeNewline) {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n    this._buf.append(str, maybeNewline);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _appendChar(char) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n    this._buf.appendChar(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _queue(char) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n    this._buf.queue(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _maybeIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n  _shouldIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      return true;\n    }\n  }\n  _maybeAddParenChar(char) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    if (char === 32) {\n      return;\n    }\n    if (char !== 10) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    const len = str.length;\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;\n    if (i === len) {\n      return;\n    }\n    const cha = str.charCodeAt(i);\n    if (cha !== 10) {\n      if (cha !== 47 || i + 1 === len) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n      const chaPost = str.charCodeAt(i + 1);\n      if (chaPost === 42) {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          return;\n        }\n      } else if (chaPost !== 47) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n  catchUp(line) {\n    if (!this.format.retainLines) return;\n    const count = line - this._buf.getCurrentLine();\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n  _getIndent() {\n    return this._indentRepeat * this._indent;\n  }\n  printTerminatorless(node, parent, isLabel) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n    } else {\n      const terminatorState = {\n        printed: false\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.tokenChar(41);\n      }\n    }\n  }\n  print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {\n    if (!node) return;\n    this._endsWithInnerRaw = false;\n    const nodeType = node.type;\n    const format = this.format;\n    const oldConcise = format.concise;\n    if (node._compact) {\n      format.concise = true;\n    }\n    const printMethod = this[nodeType];\n    if (printMethod === undefined) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n    }\n    this._printStack.push(node);\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    let shouldPrintParens = false;\n    if (forceParens) {\n      shouldPrintParens = true;\n    } else if (format.retainFunctionParens && nodeType === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      shouldPrintParens = true;\n    } else {\n      shouldPrintParens = needsParens(node, parent, this._printStack);\n    }\n    if (shouldPrintParens) {\n      this.tokenChar(40);\n      this._endsWithInnerRaw = false;\n    }\n    this._lastCommentLine = 0;\n    this._printLeadingComments(node, parent);\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      this.tokenChar(41);\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n    this._printStack.pop();\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n    this._endsWithInnerRaw = false;\n  }\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  getPossibleRaw(node) {\n    const extra = node.extra;\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0\n    };\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n      opts.iterator == null ? void 0 : opts.iterator(node, i);\n      if (i < len - 1) separator == null ? void 0 : separator();\n      if (opts.statement) {\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          var _nextNode$loc;\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n    if (opts.indent) this.dedent();\n  }\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n  printBlock(parent) {\n    const node = parent.body;\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n    this.print(node, parent);\n  }\n  _printTrailingComments(node, parent, lineOffset) {\n    const {\n      innerComments,\n      trailingComments\n    } = node;\n    if (innerComments != null && innerComments.length) {\n      this._printComments(2, innerComments, node, parent, lineOffset);\n    }\n    if (trailingComments != null && trailingComments.length) {\n      this._printComments(2, trailingComments, node, parent, lineOffset);\n    }\n  }\n  _printLeadingComments(node, parent) {\n    const comments = node.leadingComments;\n    if (!(comments != null && comments.length)) return;\n    this._printComments(0, comments, node, parent);\n  }\n  _maybePrintInnerComments() {\n    if (this._endsWithInnerRaw) this.printInnerComments();\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n  printInnerComments() {\n    const node = this._printStack[this._printStack.length - 1];\n    const comments = node.innerComments;\n    if (!(comments != null && comments.length)) return;\n    const hasSpace = this.endsWith(32);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(1, comments, node);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    this.printJoin(nodes, parent, opts);\n  }\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n    this.printJoin(items, parent, opts);\n  }\n  _printNewline(newLine, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n    if (!newLine) {\n      return;\n    }\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n    if (this._buf.hasContent()) {\n      this.newline(1);\n    }\n  }\n  _shouldPrintComment(comment) {\n    if (comment.ignore) return 0;\n    if (this._printedComments.has(comment)) return 0;\n    if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) {\n      return 2;\n    }\n    this._printedComments.add(comment);\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return 0;\n    }\n    return 1;\n  }\n  _printComment(comment, skipNewLines) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {\n      this.newline(1);\n    }\n    const lastCharCode = this.getLastChar();\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();\n        if (this._shouldIndent(47) || this.format.retainLines) {\n          indentSize += this._getIndent();\n        }\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n    if (this.endsWith(47)) this._space();\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n    if (printNewLines && skipNewLines !== 3) {\n      this.newline(1);\n    }\n  }\n  _printComments(type, comments, node, parent, lineOffset = 0) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n    const maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n      const shouldPrint = this._shouldPrintComment(comment);\n      if (shouldPrint === 2) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === 1) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === 0) {\n          let offset = 0;\n          if (i === 0) {\n            if (this._buf.hasContent() && (comment.type === \"CommentLine\" || commentStartLine != commentEndLine)) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));\n            lastLine = nodeStartLine;\n          }\n        } else if (type === 1) {\n          const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine));\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== 1) {\n          continue;\n        }\n        if (len === 1) {\n          const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);\n          const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);\n          if (type === 0) {\n            this._printComment(comment, shouldSkipNewline && node.type !== \"ObjectExpression\" || singleLine && isFunction(parent, {\n              body: node\n            }) ? 1 : 0);\n          } else if (shouldSkipNewline && type === 2) {\n            this._printComment(comment, 1);\n          } else {\n            this._printComment(comment, 0);\n          }\n        } else if (type === 1 && !(node.type === \"ObjectExpression\" && node.properties.length > 1) && node.type !== \"ClassBody\" && node.type !== \"TSInterfaceBody\") {\n          this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);\n        } else {\n          this._printComment(comment, 0);\n        }\n      }\n    }\n    if (type === 2 && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\nfunction commaSeparator() {\n  this.tokenChar(44);\n  this.space();\n}\n\n//# sourceMappingURL=printer.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = \"\";\n    this._str = \"\";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._canMarkIdName = true;\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: undefined,\n      identifierNamePos: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined\n    };\n    this._map = map;\n    this._allocQueue();\n  }\n  _allocQueue() {\n    const queue = this._queue;\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\"\n      });\n    }\n  }\n  _pushQueue(char, repeat, line, column, filename) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n    this._queueCursor++;\n  }\n  _popQueue() {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n  get() {\n    this._flush();\n    const map = this._map;\n    const result = {\n      code: (this._buf + this._str).trimRight(),\n      decodedMap: map == null ? void 0 : map.getDecoded(),\n      get __mergedMap() {\n        return this.map;\n      },\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", {\n          value,\n          writable: true\n        });\n      },\n      get rawMappings() {\n        const mappings = map == null ? void 0 : map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", {\n          value,\n          writable: true\n        });\n      }\n    };\n    return result;\n  }\n  append(str, maybeNewline) {\n    this._flush();\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n  appendChar(char) {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n  queue(char) {\n    if (char === 10) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== 32 && char !== 9) {\n          break;\n        }\n        this._queueCursor--;\n      }\n    }\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);\n  }\n  queueIndentation(char, repeat) {\n    this._pushQueue(char, repeat, undefined, undefined, undefined);\n  }\n  _flush() {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n  _appendChar(char, repeat, sourcePos) {\n    this._last = char;\n    this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n    if (char !== 10) {\n      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n  _append(str, sourcePos, maybeNewline) {\n    const len = str.length;\n    const position = this._position;\n    this._last = str.charCodeAt(len - 1);\n    if (++this._appendCount > 4096) {\n      +this._str;\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n    const {\n      column,\n      identifierName,\n      identifierNamePos,\n      filename\n    } = sourcePos;\n    let line = sourcePos.line;\n    if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n  _mark(line, column, identifierName, identifierNamePos, filename) {\n    var _this$_map;\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);\n  }\n  removeTrailingNewline() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n      this._queueCursor--;\n    }\n  }\n  removeLastSemicolon() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n      this._queueCursor--;\n    }\n  }\n  getLastChar() {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n  getNewlineCount() {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === 10 ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== 10) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === 10 ? count + 1 : count;\n  }\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== 10) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n  }\n  hasContent() {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n  exactSource(loc, cb) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n    this.source(\"start\", loc);\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n  source(prop, loc) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, 0, 0);\n  }\n  sourceWithOffset(prop, loc, lineOffset, columnOffset) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, lineOffset, columnOffset);\n  }\n  withSource(prop, loc, cb) {\n    if (this._map) {\n      this.source(prop, loc);\n    }\n    cb();\n  }\n  _normalizePosition(prop, loc, lineOffset, columnOffset) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n    if (pos) {\n      target.line = pos.line + lineOffset;\n      target.column = pos.column + columnOffset;\n      target.filename = loc.filename;\n    }\n  }\n  getCurrentColumn() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === 10) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n  getCurrentLine() {\n    let count = 0;\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === 10) {\n        count++;\n      }\n    }\n    return this._position.line + count;\n  }\n}\nexports.default = Buffer;\n\n//# sourceMappingURL=buffer.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nvar whitespace = require(\"./whitespace\");\nvar parens = require(\"./parentheses\");\nvar _t = require(\"@babel/types\");\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression\n} = _t;\nfunction expandAliases(obj) {\n  const newObj = {};\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n  return newObj;\n}\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\nfunction isOrHasCallExpression(node) {\n  if (isCallExpression(node)) {\n    return true;\n  }\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return false;\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n  const flag = find(expandedWhitespaceNodes, node, parent);\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n  return false;\n}\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, 1);\n}\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, 2);\n}\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n  return find(expandedParens, node, parent, printStack);\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nodes = void 0;\nvar _t = require(\"@babel/types\");\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\nfunction crawlInternal(node, state) {\n  if (!node) return state;\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);\n  }\n  return state;\n}\nfunction crawl(node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false\n  });\n}\nfunction isHelper(node) {\n  if (!node) return false;\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === \"require\" || node.name.charCodeAt(0) === 95;\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return state.hasFunction ? 1 | 2 : 2;\n    }\n  },\n  SwitchCase(node, parent) {\n    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);\n  },\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return 2;\n    }\n  },\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return 2;\n    }\n  },\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return 1 | 2;\n    }\n  },\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return 1 | 2;\n    }\n  },\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n      if (enabled) {\n        return 1 | 2;\n      }\n    }\n  },\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return 1 | 2;\n    }\n  }\n};\nexports.nodes = nodes;\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return 1;\n  }\n};\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return 1;\n  }\n};\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return 1;\n  }\n};\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return 1;\n  }\n};\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function ([type, amounts]) {\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    const ret = amounts ? 1 | 2 : 0;\n    nodes[type] = () => ret;\n  });\n});\n\n//# sourceMappingURL=whitespace.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSTypeAssertion = exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nvar _t = require(\"@babel/types\");\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression,\n  isTSSatisfiesExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\nfunction isTSTypeExpression(node) {\n  return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node);\n}\nconst isClassExtendsClause = (node, parent) => isClass(parent, {\n  superClass: node\n});\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  if (printStack.length < 3) return;\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 2);\n}\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, 1);\n}\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\nfunction TSAsExpression() {\n  return true;\n}\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\nfunction TSInstantiationExpression(node, parent) {\n  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n  return true;\n}\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeExpression(parent)) {\n    return true;\n  }\n  return UnaryLike(node, parent);\n}\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\nfunction LogicalExpression(node, parent) {\n  if (isTSTypeExpression(parent)) return true;\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\nfunction Identifier(node, parent, printStack) {\n  var _node$extra;\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n    left: node\n  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {\n    return true;\n  }\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);\n  }\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\nfunction isFirstInContext(printStack, checkParam) {\n  const expressionStatement = checkParam & 1;\n  const arrowBody = checkParam & 2;\n  const exportDefault = checkParam & 4;\n  const forHead = checkParam & 8;\n  const forInHead = checkParam & 16;\n  const forOfHead = checkParam & 32;\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n    if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    }))) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=parentheses.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _templateLiterals = require(\"./template-literals\");\nObject.keys(_templateLiterals).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _templateLiterals[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _templateLiterals[key];\n    }\n  });\n});\nvar _expressions = require(\"./expressions\");\nObject.keys(_expressions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _expressions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _expressions[key];\n    }\n  });\n});\nvar _statements = require(\"./statements\");\nObject.keys(_statements).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _statements[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _statements[key];\n    }\n  });\n});\nvar _classes = require(\"./classes\");\nObject.keys(_classes).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _classes[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _classes[key];\n    }\n  });\n});\nvar _methods = require(\"./methods\");\nObject.keys(_methods).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _methods[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _methods[key];\n    }\n  });\n});\nvar _modules = require(\"./modules\");\nObject.keys(_modules).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _modules[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _modules[key];\n    }\n  });\n});\nvar _types = require(\"./types\");\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\nvar _flow = require(\"./flow\");\nObject.keys(_flow).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _flow[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _flow[key];\n    }\n  });\n});\nvar _base = require(\"./base\");\nObject.keys(_base).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _base[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _base[key];\n    }\n  });\n});\nvar _jsx = require(\"./jsx\");\nObject.keys(_jsx).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _jsx[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _jsx[key];\n    }\n  });\n});\nvar _typescript = require(\"./typescript\");\nObject.keys(_typescript).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _typescript[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _typescript[key];\n    }\n  });\n});\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\nfunction TaggedTemplateExpression(node) {\n  this.print(node.tag, node);\n  this.print(node.typeParameters, node);\n  this.print(node.quasi, node);\n}\nfunction TemplateElement(node, parent) {\n  const isFirst = parent.quasis[0] === node;\n  const isLast = parent.quasis[parent.quasis.length - 1] === node;\n  const value = (isFirst ? \"`\" : \"}\") + node.value.raw + (isLast ? \"`\" : \"${\");\n  this.token(value, true);\n}\nfunction TemplateLiteral(node) {\n  const quasis = node.quasis;\n  for (let i = 0; i < quasis.length; i++) {\n    this.print(quasis[i], node);\n    if (i + 1 < quasis.length) {\n      this.print(node.expressions[i], node);\n    }\n  }\n}\n\n//# sourceMappingURL=template-literals.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.AssignmentPattern = AssignmentPattern;\nexports.AwaitExpression = AwaitExpression;\nexports.BindExpression = BindExpression;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.Decorator = Decorator;\nexports.DoExpression = DoExpression;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.Import = Import;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.ModuleExpression = ModuleExpression;\nexports.NewExpression = NewExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.PrivateName = PrivateName;\nexports.SequenceExpression = SequenceExpression;\nexports.Super = Super;\nexports.ThisExpression = ThisExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.YieldExpression = YieldExpression;\nexports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;\nvar _t = require(\"@babel/types\");\nvar n = require(\"../node\");\nconst {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression\n} = _t;\nfunction UnaryExpression(node) {\n  if (node.operator === \"void\" || node.operator === \"delete\" || node.operator === \"typeof\" || node.operator === \"throw\") {\n    this.word(node.operator);\n    this.space();\n  } else {\n    this.token(node.operator);\n  }\n  this.print(node.argument, node);\n}\nfunction DoExpression(node) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\nfunction ParenthesizedExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression, node);\n  this.tokenChar(41);\n}\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.printTerminatorless(node.argument, node, true);\n    this.token(node.operator);\n  }\n}\nfunction ConditionalExpression(node) {\n  this.print(node.test, node);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.alternate, node);\n}\nfunction NewExpression(node, parent) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n    callee: node\n  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {\n    return;\n  }\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.tokenChar(41);\n}\nfunction SequenceExpression(node) {\n  this.printList(node.expressions, node);\n}\nfunction ThisExpression() {\n  this.word(\"this\");\n}\nfunction Super() {\n  this.word(\"super\");\n}\nfunction isDecoratorMemberExpression(node) {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return !node.computed && node.property.type === \"Identifier\" && isDecoratorMemberExpression(node.object);\n    default:\n      return false;\n  }\n}\nfunction shouldParenthesizeDecoratorExpression(node) {\n  if (node.type === \"ParenthesizedExpression\") {\n    return false;\n  }\n  return !isDecoratorMemberExpression(node.type === \"CallExpression\" ? node.callee : node);\n}\nfunction _shouldPrintDecoratorsBeforeExport(node) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return typeof node.start === \"number\" && node.start === node.declaration.start;\n}\nfunction Decorator(node) {\n  this.tokenChar(64);\n  const {\n    expression\n  } = node;\n  if (shouldParenthesizeDecoratorExpression(expression)) {\n    this.tokenChar(40);\n    this.print(expression, node);\n    this.tokenChar(41);\n  } else {\n    this.print(expression, node);\n  }\n  this.newline();\n}\nfunction OptionalMemberExpression(node) {\n  this.print(node.object, node);\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n  let computed = node.computed;\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  if (computed) {\n    this.tokenChar(91);\n    this.print(node.property, node);\n    this.tokenChar(93);\n  } else {\n    if (!node.optional) {\n      this.tokenChar(46);\n    }\n    this.print(node.property, node);\n  }\n}\nfunction OptionalCallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeParameters, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.print(node.typeArguments, node);\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.tokenChar(41);\n}\nfunction CallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.tokenChar(41);\n}\nfunction Import() {\n  this.word(\"import\");\n}\nfunction AwaitExpression(node) {\n  this.word(\"await\");\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument, node, false);\n  }\n}\nfunction YieldExpression(node) {\n  this.word(\"yield\", true);\n  if (node.delegate) {\n    this.tokenChar(42);\n    if (node.argument) {\n      this.space();\n      this.print(node.argument, node);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument, node, false);\n    }\n  }\n}\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\nfunction ExpressionStatement(node) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\nfunction AssignmentPattern(node) {\n  this.print(node.left, node);\n  if (node.left.optional) this.tokenChar(63);\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right, node);\n}\nfunction AssignmentExpression(node, parent) {\n  const parens = this.inForStatementInitCounter && node.operator === \"in\" && !n.needsParens(node, parent);\n  if (parens) {\n    this.tokenChar(40);\n  }\n  this.print(node.left, node);\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n  this.space();\n  this.print(node.right, node);\n  if (parens) {\n    this.tokenChar(41);\n  }\n}\nfunction BindExpression(node) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\nfunction MemberExpression(node) {\n  this.print(node.object, node);\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n  let computed = node.computed;\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n  if (computed) {\n    this.tokenChar(91);\n    this.print(node.property, node);\n    this.tokenChar(93);\n  } else {\n    this.tokenChar(46);\n    this.print(node.property, node);\n  }\n}\nfunction MetaProperty(node) {\n  this.print(node.meta, node);\n  this.tokenChar(46);\n  this.print(node.property, node);\n}\nfunction PrivateName(node) {\n  this.tokenChar(35);\n  this.print(node.id, node);\n}\nfunction V8IntrinsicIdentifier(node) {\n  this.tokenChar(37);\n  this.word(node.name);\n}\nfunction ModuleExpression(node) {\n  this.word(\"module\", true);\n  this.space();\n  this.tokenChar(123);\n  this.indent();\n  const {\n    body\n  } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body, node);\n  this.dedent();\n  this.sourceWithOffset(\"end\", node.loc, 0, -1);\n  this.rightBrace();\n}\n\n//# sourceMappingURL=expressions.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BreakStatement = BreakStatement;\nexports.CatchClause = CatchClause;\nexports.ContinueStatement = ContinueStatement;\nexports.DebuggerStatement = DebuggerStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.ForOfStatement = exports.ForInStatement = void 0;\nexports.ForStatement = ForStatement;\nexports.IfStatement = IfStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.ReturnStatement = ReturnStatement;\nexports.SwitchCase = SwitchCase;\nexports.SwitchStatement = SwitchStatement;\nexports.ThrowStatement = ThrowStatement;\nexports.TryStatement = TryStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.WhileStatement = WhileStatement;\nexports.WithStatement = WithStatement;\nvar _t = require(\"@babel/types\");\nconst {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement\n} = _t;\nfunction WithStatement(node) {\n  this.word(\"with\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.object, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction IfStatement(node) {\n  this.word(\"if\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.space();\n  const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.tokenChar(123);\n    this.newline();\n    this.indent();\n  }\n  this.printAndIndentOnComments(node.consequent, node);\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.tokenChar(125);\n  }\n  if (node.alternate) {\n    if (this.endsWith(125)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate, node);\n  }\n}\nfunction getLastStatement(statement) {\n  const {\n    body\n  } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n  return getLastStatement(body);\n}\nfunction ForStatement(node) {\n  this.word(\"for\");\n  this.space();\n  this.tokenChar(40);\n  this.inForStatementInitCounter++;\n  this.print(node.init, node);\n  this.inForStatementInitCounter--;\n  this.tokenChar(59);\n  if (node.test) {\n    this.space();\n    this.print(node.test, node);\n  }\n  this.tokenChar(59);\n  if (node.update) {\n    this.space();\n    this.print(node.update, node);\n  }\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction WhileStatement(node) {\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction ForXStatement(node) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.tokenChar(40);\n  this.print(node.left, node);\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nconst ForInStatement = ForXStatement;\nexports.ForInStatement = ForInStatement;\nconst ForOfStatement = ForXStatement;\nexports.ForOfStatement = ForOfStatement;\nfunction DoWhileStatement(node) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.semicolon();\n}\nfunction printStatementAfterKeyword(printer, node, parent, isLabel) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node, parent, isLabel);\n  }\n  printer.semicolon();\n}\nfunction BreakStatement(node) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\nfunction ContinueStatement(node) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\nfunction ReturnStatement(node) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\nfunction ThrowStatement(node) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\nfunction LabeledStatement(node) {\n  this.print(node.label, node);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.body, node);\n}\nfunction TryStatement(node) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block, node);\n  this.space();\n  if (node.handlers) {\n    this.print(node.handlers[0], node);\n  } else {\n    this.print(node.handler, node);\n  }\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer, node);\n  }\n}\nfunction CatchClause(node) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.tokenChar(40);\n    this.print(node.param, node);\n    this.print(node.param.typeAnnotation, node);\n    this.tokenChar(41);\n    this.space();\n  }\n  this.print(node.body, node);\n}\nfunction SwitchStatement(node) {\n  this.word(\"switch\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.discriminant, node);\n  this.tokenChar(41);\n  this.space();\n  this.tokenChar(123);\n  this.printSequence(node.cases, node, {\n    indent: true,\n    addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    }\n  });\n  this.tokenChar(125);\n}\nfunction SwitchCase(node) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test, node);\n    this.tokenChar(58);\n  } else {\n    this.word(\"default\");\n    this.tokenChar(58);\n  }\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, node, {\n      indent: true\n    });\n  }\n}\nfunction DebuggerStatement() {\n  this.word(\"debugger\");\n  this.semicolon();\n}\nfunction VariableDeclaration(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  const {\n    kind\n  } = node;\n  this.word(kind, kind === \"using\");\n  this.space();\n  let hasInits = false;\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        hasInits = true;\n      }\n    }\n  }\n  this.printList(node.declarations, node, {\n    separator: hasInits ? function () {\n      this.tokenChar(44);\n      this.newline();\n    } : undefined,\n    indent: node.declarations.length > 1 ? true : false\n  });\n  if (isFor(parent)) {\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n  this.semicolon();\n}\nfunction VariableDeclarator(node) {\n  this.print(node.id, node);\n  if (node.definite) this.tokenChar(33);\n  this.print(node.id.typeAnnotation, node);\n  if (node.init) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.init, node);\n  }\n}\n\n//# sourceMappingURL=statements.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClassAccessorProperty = ClassAccessorProperty;\nexports.ClassBody = ClassBody;\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassMethod = ClassMethod;\nexports.ClassPrivateMethod = ClassPrivateMethod;\nexports.ClassPrivateProperty = ClassPrivateProperty;\nexports.ClassProperty = ClassProperty;\nexports.StaticBlock = StaticBlock;\nexports._classMethodHead = _classMethodHead;\nvar _t = require(\"@babel/types\");\nconst {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration\n} = _t;\nfunction ClassDeclaration(node, parent) {\n  const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n  if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {\n    this.printJoin(node.decorators, node);\n  }\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"class\");\n  if (node.id) {\n    this.space();\n    this.print(node.id, node);\n  }\n  this.print(node.typeParameters, node);\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass, node);\n    this.print(node.superTypeParameters, node);\n  }\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction ClassBody(node) {\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.indent();\n    this.printSequence(node.body, node);\n    this.dedent();\n    if (!this.endsWith(10)) this.newline();\n    this.sourceWithOffset(\"end\", node.loc, 0, -1);\n    this.rightBrace();\n  }\n}\nfunction ClassProperty(node) {\n  var _node$key$loc, _node$key$loc$end;\n  this.printJoin(node.decorators, node);\n  const endLine = (_node$key$loc = node.key.loc) == null ? void 0 : (_node$key$loc$end = _node$key$loc.end) == null ? void 0 : _node$key$loc$end.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key, node);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\nfunction ClassAccessorProperty(node) {\n  var _node$key$loc2, _node$key$loc2$end;\n  this.printJoin(node.decorators, node);\n  const endLine = (_node$key$loc2 = node.key.loc) == null ? void 0 : (_node$key$loc2$end = _node$key$loc2.end) == null ? void 0 : _node$key$loc2$end.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  this.word(\"accessor\", true);\n  this.space();\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key, node);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\nfunction ClassPrivateProperty(node) {\n  this.printJoin(node.decorators, node);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.key, node);\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\nfunction ClassMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction ClassPrivateMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction _classMethodHead(node) {\n  var _node$key$loc3, _node$key$loc3$end;\n  this.printJoin(node.decorators, node);\n  const endLine = (_node$key$loc3 = node.key.loc) == null ? void 0 : (_node$key$loc3$end = _node$key$loc3.end) == null ? void 0 : _node$key$loc3$end.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\nfunction StaticBlock(node) {\n  this.word(\"static\");\n  this.space();\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.sourceWithOffset(\"end\", node.loc, 0, -1);\n    this.rightBrace();\n  }\n}\n\n//# sourceMappingURL=classes.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports._functionHead = _functionHead;\nexports._methodHead = _methodHead;\nexports._param = _param;\nexports._parameters = _parameters;\nexports._params = _params;\nexports._predicate = _predicate;\nvar _t = require(\"@babel/types\");\nconst {\n  isIdentifier\n} = _t;\nfunction _params(node, idNode, parentNode) {\n  this.print(node.typeParameters, node);\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n  this.tokenChar(40);\n  this._parameters(node.params, node);\n  this.tokenChar(41);\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, node, noLineTerminator);\n  this._noLineTerminator = noLineTerminator;\n}\nfunction _parameters(parameters, parent) {\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i], parent);\n    if (i < parameters.length - 1) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n}\nfunction _param(parameter, parent) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n  if (parameter.optional) {\n    this.tokenChar(63);\n  }\n  this.print(parameter.typeAnnotation, parameter);\n}\nfunction _methodHead(node) {\n  const kind = node.kind;\n  const key = node.key;\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  if (kind === \"method\" || kind === \"init\") {\n    if (node.generator) {\n      this.tokenChar(42);\n    }\n  }\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(key, node);\n    this.tokenChar(93);\n  } else {\n    this.print(key, node);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  this._params(node, node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key, undefined);\n}\nfunction _predicate(node, noLineTerminatorAfter) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.tokenChar(58);\n    }\n    this.space();\n    this.print(node.predicate, node, noLineTerminatorAfter);\n  }\n}\nfunction _functionHead(node, parent) {\n  if (node.async) {\n    this.word(\"async\");\n    this._endsWithInnerRaw = false;\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    this._endsWithInnerRaw = false;\n    this.tokenChar(42);\n  }\n  this.space();\n  if (node.id) {\n    this.print(node.id, node);\n  }\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\nfunction FunctionExpression(node, parent) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body, node);\n}\nfunction ArrowFunctionExpression(node, parent) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  let firstParam;\n  if (!this.format.retainLines && node.params.length === 1 && isIdentifier(firstParam = node.params[0]) && !hasTypesOrComments(node, firstParam)) {\n    this.print(firstParam, node, true);\n  } else {\n    this._params(node, undefined, parent);\n  }\n  this._predicate(node, true);\n  this.space();\n  this.printInnerComments();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.body, node);\n}\nfunction hasTypesOrComments(node, param) {\n  var _param$leadingComment, _param$trailingCommen;\n  return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);\n}\nfunction _getFuncIdName(idNode, parent) {\n  let id = idNode;\n  if (!id && parent) {\n    const parentType = parent.type;\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (parentType === \"AssignmentExpression\" || parentType === \"AssignmentPattern\") {\n      id = parent.left;\n    } else if (parentType === \"ObjectProperty\" || parentType === \"ClassProperty\") {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (parentType === \"ClassPrivateProperty\" || parentType === \"ClassAccessorProperty\") {\n      id = parent.key;\n    }\n  }\n  if (!id) return;\n  let nameInfo;\n  if (id.type === \"Identifier\") {\n    var _id$loc, _id$loc2;\n    nameInfo = {\n      pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,\n      name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name\n    };\n  } else if (id.type === \"PrivateName\") {\n    var _id$loc3;\n    nameInfo = {\n      pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,\n      name: \"#\" + id.id.name\n    };\n  } else if (id.type === \"StringLiteral\") {\n    var _id$loc4;\n    nameInfo = {\n      pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,\n      name: id.value\n    };\n  }\n  return nameInfo;\n}\n\n//# sourceMappingURL=methods.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.ImportSpecifier = ImportSpecifier;\nexports._printAssertions = _printAssertions;\nvar _t = require(\"@babel/types\");\nconst {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement\n} = _t;\nfunction ImportSpecifier(node) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n  this.print(node.imported, node);\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n  }\n}\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local, node);\n}\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported, node);\n}\nfunction ExportSpecifier(node) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.print(node.local, node);\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\nfunction ExportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported, node);\n}\nfunction _printAssertions(node) {\n  this.word(\"assert\");\n  this.space();\n  this.tokenChar(123);\n  this.space();\n  this.printList(node.assertions, node);\n  this.space();\n  this.tokenChar(125);\n}\nfunction ExportAllDeclaration(node) {\n  var _node$assertions;\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.tokenChar(42);\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAssertions(node);\n  } else {\n    this.print(node.source, node);\n  }\n  this.semicolon();\n}\nfunction maybePrintDecoratorsBeforeExport(printer, node) {\n  if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {\n    printer.printJoin(node.declaration.decorators, node);\n  }\n}\nfunction ExportNamedDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n    const specifiers = node.specifiers.slice(0);\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n        if (specifiers.length) {\n          this.tokenChar(44);\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      this.tokenChar(123);\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n      this.tokenChar(125);\n    }\n    if (node.source) {\n      var _node$assertions2;\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if ((_node$assertions2 = node.assertions) != null && _node$assertions2.length) {\n        this.print(node.source, node, true);\n        this.space();\n        this._printAssertions(node);\n      } else {\n        this.print(node.source, node);\n      }\n    }\n    this.semicolon();\n  }\n}\nfunction ExportDefaultDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  const declar = node.declaration;\n  this.print(declar, node);\n  if (!isStatement(declar)) this.semicolon();\n}\nfunction ImportDeclaration(node) {\n  var _node$assertions3;\n  this.word(\"import\");\n  this.space();\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  }\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift(), node);\n      if (specifiers.length) {\n        this.tokenChar(44);\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n  if (specifiers.length) {\n    this.tokenChar(123);\n    this.space();\n    this.printList(specifiers, node);\n    this.space();\n    this.tokenChar(125);\n  } else if (isTypeKind && !hasSpecifiers) {\n    this.tokenChar(123);\n    this.tokenChar(125);\n  }\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n  if ((_node$assertions3 = node.assertions) != null && _node$assertions3.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAssertions(node);\n  } else {\n    this.print(node.source, node);\n  }\n  {\n    var _node$attributes;\n    if ((_node$attributes = node.attributes) != null && _node$attributes.length) {\n      this.space();\n      this.word(\"with\");\n      this.space();\n      this.printList(node.attributes, node);\n    }\n  }\n  this.semicolon();\n}\nfunction ImportAttribute(node) {\n  this.print(node.key);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ImportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local, node);\n}\n\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.BigIntLiteral = BigIntLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.DecimalLiteral = DecimalLiteral;\nexports.Identifier = Identifier;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.RecordExpression = RecordExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.StringLiteral = StringLiteral;\nexports.TopicReference = TopicReference;\nexports.TupleExpression = TupleExpression;\nvar _t = require(\"@babel/types\");\nvar _jsesc = require(\"jsesc\");\nconst {\n  isAssignmentPattern,\n  isIdentifier\n} = _t;\nfunction Identifier(node) {\n  var _node$loc;\n  this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);\n  this.word(node.name);\n}\nfunction ArgumentPlaceholder() {\n  this.tokenChar(63);\n}\nfunction RestElement(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\nfunction ObjectExpression(node) {\n  const props = node.properties;\n  this.tokenChar(123);\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n  this.sourceWithOffset(\"end\", node.loc, 0, -1);\n  this.tokenChar(125);\n}\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators, node);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators, node);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value, node);\n      return;\n    }\n    this.print(node.key, node);\n    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\nfunction ArrayExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  this.tokenChar(91);\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    } else {\n      this.tokenChar(44);\n    }\n  }\n  this.tokenChar(93);\n}\nfunction RecordExpression(node) {\n  const props = node.properties;\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"{|\";\n    endToken = \"|}\";\n  } else if (this.format.recordAndTupleSyntaxType !== \"hash\" && this.format.recordAndTupleSyntaxType != null) {\n    throw new Error(`The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n  } else {\n    startToken = \"#{\";\n    endToken = \"}\";\n  }\n  this.token(startToken);\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n  this.token(endToken);\n}\nfunction TupleExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"[|\";\n    endToken = \"|]\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n  }\n  this.token(startToken);\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    }\n  }\n  this.token(endToken);\n}\nfunction RegExpLiteral(node) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\nfunction BooleanLiteral(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteral() {\n  this.word(\"null\");\n}\nfunction NumericLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + \"\";\n  if (opts.numbers) {\n    this.number(_jsesc(node.value, opts));\n  } else if (raw == null) {\n    this.number(value);\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\nfunction StringLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const val = _jsesc(node.value, this.format.jsescOption);\n  this.token(val);\n}\nfunction BigIntLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\nfunction DecimalLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"m\");\n}\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nfunction TopicReference() {\n  const {\n    topicToken\n  } = this.format;\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(`The \"topicToken\" generator option must be one of ` + `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`);\n  }\n}\nfunction PipelineTopicExpression(node) {\n  this.print(node.expression, node);\n}\nfunction PipelineBareFunction(node) {\n  this.print(node.callee, node);\n}\nfunction PipelinePrimaryTopicReference() {\n  this.tokenChar(35);\n}\n\n//# sourceMappingURL=types.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n});\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nvar _t = require(\"@babel/types\");\nvar _modules = require(\"./modules\");\nvar _types2 = require(\"./types\");\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n  this.semicolon();\n}\nfunction InferredPredicate() {\n  this.tokenChar(37);\n  this.word(\"checks\");\n}\nfunction DeclaredPredicate(node) {\n  this.tokenChar(37);\n  this.word(\"checks\");\n  this.tokenChar(40);\n  this.print(node.value, node);\n  this.tokenChar(41);\n}\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.tokenChar(46);\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n  FlowExportDeclaration.call(this, node);\n}\nfunction DeclareExportAllDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  _modules.ExportAllDeclaration.call(this, node);\n}\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id, node);\n  this.tokenChar(44);\n}\nfunction enumInitializedMember(context, node) {\n  const {\n    id,\n    init\n  } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.tokenChar(123);\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n    this.tokenChar(125);\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n    this.semicolon();\n  }\n}\nfunction ExistsTypeAnnotation() {\n  this.tokenChar(42);\n}\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n  if (node.this) {\n    this.word(\"this\");\n    this.tokenChar(58);\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n    if (node.params.length || node.rest) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n  this.printList(node.params, node);\n  if (node.rest) {\n    if (node.params.length) {\n      this.tokenChar(44);\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n  this.tokenChar(41);\n  if (parent && (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"ObjectTypeInternalSlot\" || parent.type === \"DeclareFunction\" || parent.type === \"ObjectTypeProperty\" && parent.method)) {\n    this.tokenChar(58);\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n  this.space();\n  this.print(node.returnType, node);\n}\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.tokenChar(63);\n  if (node.name) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.typeAnnotation, node);\n}\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node, true);\n}\nfunction _interfaceish(node) {\n  var _node$extends;\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n  if (node.implements && node.implements.length) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction _variance(node) {\n  if (node.variance) {\n    if (node.variance.kind === \"plus\") {\n      this.tokenChar(43);\n    } else if (node.variance.kind === \"minus\") {\n      this.tokenChar(45);\n    }\n  }\n}\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction andSeparator() {\n  this.space();\n  this.tokenChar(38);\n  this.space();\n}\nfunction InterfaceTypeAnnotation(node) {\n  this.word(\"interface\");\n  if (node.extends && node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\nfunction NullableTypeAnnotation(node) {\n  this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\nfunction TupleTypeAnnotation(node) {\n  this.tokenChar(91);\n  this.printList(node.types, node);\n  this.tokenChar(93);\n}\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\nfunction TypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction TypeParameterInstantiation(node) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n  this.tokenChar(62);\n}\nfunction TypeParameter(node) {\n  this._variance(node);\n  this.word(node.name);\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.supertype) {\n    this.tokenChar(58);\n    this.space();\n    this.print(node.supertype, node);\n  }\n  if (node.impltype) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.impltype, node);\n  }\n  this.semicolon();\n}\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.tokenChar(123);\n  }\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n  if (props.length) {\n    this.newline();\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.tokenChar(44);\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.tokenChar(125);\n  }\n}\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.tokenChar(91);\n  this.print(node.id, node);\n  this.tokenChar(93);\n  this.tokenChar(93);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.tokenChar(91);\n  if (node.id) {\n    this.print(node.id, node);\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.key, node);\n  this.tokenChar(93);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key, node);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.tokenChar(46);\n  this.print(node.id, node);\n}\nfunction SymbolTypeAnnotation() {\n  this.word(\"symbol\");\n}\nfunction orSeparator() {\n  this.space();\n  this.tokenChar(124);\n  this.space();\n}\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\nfunction TypeCastExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\nfunction Variance(node) {\n  if (node.kind === \"plus\") {\n    this.tokenChar(43);\n  } else {\n    this.tokenChar(45);\n  }\n}\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\n\n//# sourceMappingURL=flow.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockStatement = BlockStatement;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.File = File;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\nexports.Program = Program;\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter, node);\n  }\n  this.print(node.program, node);\n}\nfunction Program(node) {\n  var _node$directives;\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n  const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n  if (directivesLen) {\n    var _node$directives$trai;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, node, {\n      trailingCommentsLineOffset: newline\n    });\n    if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body, node);\n}\nfunction BlockStatement(node) {\n  var _node$directives2;\n  this.tokenChar(123);\n  const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;\n  if (directivesLen) {\n    var _node$directives$trai2;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, node, {\n      indent: true,\n      trailingCommentsLineOffset: newline\n    });\n    if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body, node, {\n    indent: true\n  });\n  this.sourceWithOffset(\"end\", node.loc, 0, -1);\n  this.rightBrace();\n}\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const {\n    value\n  } = node;\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\"Malformed AST: it is not possible to print a directive containing\" + \" both unescaped single and double quotes.\");\n  }\n}\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\nfunction Placeholder(node) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n\n//# sourceMappingURL=base.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSXAttribute = JSXAttribute;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXClosingFragment = JSXClosingFragment;\nexports.JSXElement = JSXElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXFragment = JSXFragment;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXOpeningFragment = JSXOpeningFragment;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\nfunction JSXAttribute(node) {\n  this.print(node.name, node);\n  if (node.value) {\n    this.tokenChar(61);\n    this.print(node.value, node);\n  }\n}\nfunction JSXIdentifier(node) {\n  this.word(node.name);\n}\nfunction JSXNamespacedName(node) {\n  this.print(node.namespace, node);\n  this.tokenChar(58);\n  this.print(node.name, node);\n}\nfunction JSXMemberExpression(node) {\n  this.print(node.object, node);\n  this.tokenChar(46);\n  this.print(node.property, node);\n}\nfunction JSXSpreadAttribute(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.argument, node);\n  this.tokenChar(125);\n}\nfunction JSXExpressionContainer(node) {\n  this.tokenChar(123);\n  this.print(node.expression, node);\n  this.tokenChar(125);\n}\nfunction JSXSpreadChild(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.expression, node);\n  this.tokenChar(125);\n}\nfunction JSXText(node) {\n  const raw = this.getPossibleRaw(node);\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\nfunction JSXElement(node) {\n  const open = node.openingElement;\n  this.print(open, node);\n  if (open.selfClosing) return;\n  this.indent();\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n  this.dedent();\n  this.print(node.closingElement, node);\n}\nfunction spaceSeparator() {\n  this.space();\n}\nfunction JSXOpeningElement(node) {\n  this.tokenChar(60);\n  this.print(node.name, node);\n  this.print(node.typeParameters, node);\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, node, {\n      separator: spaceSeparator\n    });\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/>\");\n  } else {\n    this.tokenChar(62);\n  }\n}\nfunction JSXClosingElement(node) {\n  this.token(\"</\");\n  this.print(node.name, node);\n  this.tokenChar(62);\n}\nfunction JSXEmptyExpression() {\n  this.printInnerComments();\n}\nfunction JSXFragment(node) {\n  this.print(node.openingFragment, node);\n  this.indent();\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n  this.dedent();\n  this.print(node.closingFragment, node);\n}\nfunction JSXOpeningFragment() {\n  this.tokenChar(60);\n  this.tokenChar(62);\n}\nfunction JSXClosingFragment() {\n  this.token(\"</\");\n  this.tokenChar(62);\n}\n\n//# sourceMappingURL=jsx.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nfunction TSTypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    this.tokenChar(44);\n  }\n  this.tokenChar(62);\n}\nfunction TSTypeParameter(node) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n  this.word(node.name);\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this._param(node.parameter);\n}\nfunction TSDeclareFunction(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.tokenChar(59);\n}\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n  this.tokenChar(59);\n}\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.tokenChar(46);\n  this.print(node.right, node);\n}\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n  this.tokenChar(59);\n}\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n  this.print(node.key, node);\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this._parameters(node.parameters, node);\n  this.tokenChar(93);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(59);\n}\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\nfunction TSThisType() {\n  this.word(\"this\");\n}\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n  this._parameters(parameters, node);\n  this.tokenChar(41);\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType.typeAnnotation, node);\n}\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node, true);\n  this.print(node.typeParameters, node, true);\n}\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n  if (node.typeParameters) {\n    this.print(node.typeParameters, node);\n  }\n}\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  tsPrintBraced(this, members, node);\n}\nfunction tsPrintBraced(printer, members, node) {\n  printer.token(\"{\");\n  if (members.length) {\n    printer.indent();\n    printer.newline();\n    for (const member of members) {\n      printer.print(member, node);\n      printer.newline();\n    }\n    printer.dedent();\n  }\n  printer.sourceWithOffset(\"end\", node.loc, 0, -1);\n  printer.rightBrace();\n}\nfunction TSArrayType(node) {\n  this.print(node.elementType, node, true);\n  this.token(\"[]\");\n}\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, node);\n  this.tokenChar(93);\n}\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(63);\n}\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType, node);\n}\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  printer.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n  });\n}\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.tokenChar(123);\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n  this.tokenChar(93);\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n  this.tokenChar(58);\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.tokenChar(125);\n}\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n  this.space();\n  this.print(body, node);\n}\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation, node);\n  this.tokenChar(59);\n}\nfunction TSTypeExpression(node) {\n  var _expression$trailingC;\n  const {\n    type,\n    expression,\n    typeAnnotation\n  } = node;\n  const forceParens = !!((_expression$trailingC = expression.trailingComments) != null && _expression$trailingC.length);\n  this.print(expression, node, true, undefined, forceParens);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation, node);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression, node);\n}\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  tsPrintBraced(this, members, node);\n}\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n  this.tokenChar(44);\n}\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n  this.print(id, node);\n  if (!node.body) {\n    this.tokenChar(59);\n    return;\n  }\n  let body = node.body;\n  while (body.type === \"TSModuleDeclaration\") {\n    this.tokenChar(46);\n    this.print(body.id, body);\n    body = body.body;\n  }\n  this.space();\n  this.print(body, node);\n}\nfunction TSModuleBlock(node) {\n  tsPrintBraced(this, node.body, node);\n}\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.tokenChar(40);\n  this.print(argument, node);\n  this.tokenChar(41);\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier, node);\n  }\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference, node);\n  this.tokenChar(59);\n}\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.tokenChar(41);\n}\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.tokenChar(33);\n}\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression, node);\n  this.tokenChar(59);\n}\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n  this._parameters(parameters, node);\n  this.tokenChar(41);\n  const returnType = node.typeAnnotation;\n  this.print(returnType, node);\n}\nfunction tsPrintClassMemberModifiers(node) {\n  const isField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.override) {\n    this.word(\"override\");\n    this.space();\n  }\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}\n\n//# sourceMappingURL=typescript.js.map\n"]}