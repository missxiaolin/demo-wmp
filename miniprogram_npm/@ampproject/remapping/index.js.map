{"version":3,"sources":["remapping.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@jridgewell/trace-mapping'), require('@jridgewell/gen-mapping')) :\n    typeof define === 'function' && define.amd ? define(['@jridgewell/trace-mapping', '@jridgewell/gen-mapping'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));\n})(this, (function (traceMapping, genMapping) { \n\n    const SOURCELESS_MAPPING = {\n        source: null,\n        column: null,\n        line: null,\n        name: null,\n        content: null,\n    };\n    const EMPTY_SOURCES = [];\n    function Source(map, sources, source, content) {\n        return {\n            map,\n            sources,\n            source,\n            content,\n        };\n    }\n    /**\n     * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n     * (which may themselves be SourceMapTrees).\n     */\n    function MapSource(map, sources) {\n        return Source(map, sources, '', null);\n    }\n    /**\n     * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n     * segment tracing ends at the `OriginalSource`.\n     */\n    function OriginalSource(source, content) {\n        return Source(null, EMPTY_SOURCES, source, content);\n    }\n    /**\n     * traceMappings is only called on the root level SourceMapTree, and begins the process of\n     * resolving each mapping in terms of the original source files.\n     */\n    function traceMappings(tree) {\n        const gen = new genMapping.GenMapping({ file: tree.map.file });\n        const { sources: rootSources, map } = tree;\n        const rootNames = map.names;\n        const rootMappings = traceMapping.decodedMappings(map);\n        for (let i = 0; i < rootMappings.length; i++) {\n            const segments = rootMappings[i];\n            let lastSource = null;\n            let lastSourceLine = null;\n            let lastSourceColumn = null;\n            for (let j = 0; j < segments.length; j++) {\n                const segment = segments[j];\n                const genCol = segment[0];\n                let traced = SOURCELESS_MAPPING;\n                // 1-length segments only move the current generated column, there's no source information\n                // to gather from it.\n                if (segment.length !== 1) {\n                    const source = rootSources[segment[1]];\n                    traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n                    // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n                    // respective segment into an original source.\n                    if (traced == null)\n                        continue;\n                }\n                // So we traced a segment down into its original source file. Now push a\n                // new segment pointing to this location.\n                const { column, line, name, content, source } = traced;\n                if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n                    continue;\n                }\n                lastSourceLine = line;\n                lastSourceColumn = column;\n                lastSource = source;\n                // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n                genMapping.addSegment(gen, i, genCol, source, line, column, name);\n                if (content != null)\n                    genMapping.setSourceContent(gen, source, content);\n            }\n        }\n        return gen;\n    }\n    /**\n     * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n     * child SourceMapTrees, until we find the original source map.\n     */\n    function originalPositionFor(source, line, column, name) {\n        if (!source.map) {\n            return { column, line, name, source: source.source, content: source.content };\n        }\n        const segment = traceMapping.traceSegment(source.map, line, column);\n        // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n        if (segment == null)\n            return null;\n        // 1-length segments only move the current generated column, there's no source information\n        // to gather from it.\n        if (segment.length === 1)\n            return SOURCELESS_MAPPING;\n        return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n    }\n\n    function asArray(value) {\n        if (Array.isArray(value))\n            return value;\n        return [value];\n    }\n    /**\n     * Recursively builds a tree structure out of sourcemap files, with each node\n     * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n     * `OriginalSource`s and `SourceMapTree`s.\n     *\n     * Every sourcemap is composed of a collection of source files and mappings\n     * into locations of those source files. When we generate a `SourceMapTree` for\n     * the sourcemap, we attempt to load each source file's own sourcemap. If it\n     * does not have an associated sourcemap, it is considered an original,\n     * unmodified source file.\n     */\n    function buildSourceMapTree(input, loader) {\n        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ''));\n        const map = maps.pop();\n        for (let i = 0; i < maps.length; i++) {\n            if (maps[i].sources.length > 1) {\n                throw new Error(`Transformation map ${i} must have exactly one source file.\\n` +\n                    'Did you specify these with the most recent transformation maps first?');\n            }\n        }\n        let tree = build(map, loader, '', 0);\n        for (let i = maps.length - 1; i >= 0; i--) {\n            tree = MapSource(maps[i], [tree]);\n        }\n        return tree;\n    }\n    function build(map, loader, importer, importerDepth) {\n        const { resolvedSources, sourcesContent } = map;\n        const depth = importerDepth + 1;\n        const children = resolvedSources.map((sourceFile, i) => {\n            // The loading context gives the loader more information about why this file is being loaded\n            // (eg, from which importer). It also allows the loader to override the location of the loaded\n            // sourcemap/original source, or to override the content in the sourcesContent field if it's\n            // an unmodified source file.\n            const ctx = {\n                importer,\n                depth,\n                source: sourceFile || '',\n                content: undefined,\n            };\n            // Use the provided loader callback to retrieve the file's sourcemap.\n            // TODO: We should eventually support async loading of sourcemap files.\n            const sourceMap = loader(ctx.source, ctx);\n            const { source, content } = ctx;\n            // If there is a sourcemap, then we need to recurse into it to load its source files.\n            if (sourceMap)\n                return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);\n            // Else, it's an an unmodified source file.\n            // The contents of this unmodified source file can be overridden via the loader context,\n            // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n            // the importing sourcemap's `sourcesContent` field.\n            const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n            return OriginalSource(source, sourceContent);\n        });\n        return MapSource(map, children);\n    }\n\n    /**\n     * A SourceMap v3 compatible sourcemap, which only includes fields that were\n     * provided to it.\n     */\n    class SourceMap {\n        constructor(map, options) {\n            const out = options.decodedMappings ? genMapping.decodedMap(map) : genMapping.encodedMap(map);\n            this.version = out.version; // SourceMap spec says this should be first.\n            this.file = out.file;\n            this.mappings = out.mappings;\n            this.names = out.names;\n            this.sourceRoot = out.sourceRoot;\n            this.sources = out.sources;\n            if (!options.excludeContent) {\n                this.sourcesContent = out.sourcesContent;\n            }\n        }\n        toString() {\n            return JSON.stringify(this);\n        }\n    }\n\n    /**\n     * Traces through all the mappings in the root sourcemap, through the sources\n     * (and their sourcemaps), all the way back to the original source location.\n     *\n     * `loader` will be called every time we encounter a source file. If it returns\n     * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n     * it returns a falsey value, that source file is treated as an original,\n     * unmodified source file.\n     *\n     * Pass `excludeContent` to exclude any self-containing source file content\n     * from the output sourcemap.\n     *\n     * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n     * VLQ encoded) mappings.\n     */\n    function remapping(input, loader, options) {\n        const opts = typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n        const tree = buildSourceMapTree(input, loader);\n        return new SourceMap(traceMappings(tree), opts);\n    }\n\n    return remapping;\n\n}));\n//# sourceMappingURL=remapping.umd.js.map\n"]}