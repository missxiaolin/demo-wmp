{"version":3,"sources":["index.js","lib/encoder.js","lib/decoder.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * @author shaozilee\n *\n * support 1bit 4bit 8bit 24bit decode\n * encode with 24bit\n * \n */\n\nvar encode = require('./lib/encoder'),\n    decode = require('./lib/decoder');\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n","/**\n * @author shaozilee\n *\n * BMP format encoder,encode 24bit BMP\n * Not support quality compression\n *\n */\n\nfunction BmpEncoder(imgData){\n\tthis.buffer = imgData.data;\n\tthis.width = imgData.width;\n\tthis.height = imgData.height;\n\tthis.extraBytes = this.width%4;\n\tthis.rgbSize = this.height*(3*this.width+this.extraBytes);\n\tthis.headerInfoSize = 40;\n\n\tthis.data = [];\n\t/******************header***********************/\n\tthis.flag = \"BM\";\n\tthis.reserved = 0;\n\tthis.offset = 54;\n\tthis.fileSize = this.rgbSize+this.offset;\n\tthis.planes = 1;\n\tthis.bitPP = 24;\n\tthis.compress = 0;\n\tthis.hr = 0;\n\tthis.vr = 0;\n\tthis.colors = 0;\n\tthis.importantColors = 0;\n}\n\nBmpEncoder.prototype.encode = function() {\n\tvar tempBuffer = new Buffer(this.offset+this.rgbSize);\n\tthis.pos = 0;\n\ttempBuffer.write(this.flag,this.pos,2);this.pos+=2;\n\ttempBuffer.writeUInt32LE(this.fileSize,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.reserved,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.offset,this.pos);this.pos+=4;\n\n\ttempBuffer.writeUInt32LE(this.headerInfoSize,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.width,this.pos);this.pos+=4;\n\ttempBuffer.writeInt32LE(-this.height,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt16LE(this.planes,this.pos);this.pos+=2;\n\ttempBuffer.writeUInt16LE(this.bitPP,this.pos);this.pos+=2;\n\ttempBuffer.writeUInt32LE(this.compress,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.rgbSize,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.hr,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.vr,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.colors,this.pos);this.pos+=4;\n\ttempBuffer.writeUInt32LE(this.importantColors,this.pos);this.pos+=4;\n\n\tvar i=0;\n\tvar rowBytes = 3*this.width+this.extraBytes;\n\n\tfor (var y = 0; y <this.height; y++){\n\t\tfor (var x = 0; x < this.width; x++){\n\t\t\tvar p = this.pos+y*rowBytes+x*3;\n\t\t\ti++;//a\n\t\t\ttempBuffer[p]= this.buffer[i++];//b\n\t\t\ttempBuffer[p+1] = this.buffer[i++];//g\n\t\t\ttempBuffer[p+2]  = this.buffer[i++];//r\n\t\t}\n\t\tif(this.extraBytes>0){\n\t\t\tvar fillOffset = this.pos+y*rowBytes+this.width*3;\n\t\t\ttempBuffer.fill(0,fillOffset,fillOffset+this.extraBytes);\n\t\t}\n\t}\n\n\treturn tempBuffer;\n};\n\nmodule.exports = function(imgData, quality) {\n  if (typeof quality === 'undefined') quality = 100;\n \tvar encoder = new BmpEncoder(imgData);\n\tvar data = encoder.encode();\n  return {\n    data: data,\n    width: imgData.width,\n    height: imgData.height\n  };\n};\n","/**\n * @author shaozilee\n *\n * Bmp format decoder,support 1bit 4bit 8bit 24bit bmp\n *\n */\n\nfunction BmpDecoder(buffer,is_with_alpha) {\n  this.pos = 0;\n  this.buffer = buffer;\n  this.is_with_alpha = !!is_with_alpha;\n  this.bottom_up = true;\n  this.flag = this.buffer.toString(\"utf-8\", 0, this.pos += 2);\n  if (this.flag != \"BM\") throw new Error(\"Invalid BMP File\");\n  this.parseHeader();\n  this.parseRGBA();\n}\n\nBmpDecoder.prototype.parseHeader = function() {\n  this.fileSize = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.reserved = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.offset = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.headerSize = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.width = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.height = this.buffer.readInt32LE(this.pos);\n  this.pos += 4;\n  this.planes = this.buffer.readUInt16LE(this.pos);\n  this.pos += 2;\n  this.bitPP = this.buffer.readUInt16LE(this.pos);\n  this.pos += 2;\n  this.compress = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.rawSize = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.hr = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.vr = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.colors = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n  this.importantColors = this.buffer.readUInt32LE(this.pos);\n  this.pos += 4;\n\n  if(this.bitPP === 16 && this.is_with_alpha){\n    this.bitPP = 15\n  }\n  if (this.bitPP < 15) {\n    var len = this.colors === 0 ? 1 << this.bitPP : this.colors;\n    this.palette = new Array(len);\n    for (var i = 0; i < len; i++) {\n      var blue = this.buffer.readUInt8(this.pos++);\n      var green = this.buffer.readUInt8(this.pos++);\n      var red = this.buffer.readUInt8(this.pos++);\n      var quad = this.buffer.readUInt8(this.pos++);\n      this.palette[i] = {\n        red: red,\n        green: green,\n        blue: blue,\n        quad: quad\n      };\n    }\n  }\n  if(this.height < 0) {\n    this.height *= -1;\n    this.bottom_up = false;\n  }\n\n}\n\nBmpDecoder.prototype.parseRGBA = function() {\n    var bitn = \"bit\" + this.bitPP;\n    var len = this.width * this.height * 4;\n    this.data = new Buffer(len);\n    this[bitn]();\n};\n\nBmpDecoder.prototype.bit1 = function() {\n  var xlen = Math.ceil(this.width / 8);\n  var mode = xlen%4;\n  var y = this.height >= 0 ? this.height - 1 : -this.height\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y\n    for (var x = 0; x < xlen; x++) {\n      var b = this.buffer.readUInt8(this.pos++);\n      var location = line * this.width * 4 + x*8*4;\n      for (var i = 0; i < 8; i++) {\n        if(x*8+i<this.width){\n          var rgb = this.palette[((b>>(7-i))&0x1)];\n\n          this.data[location+i*4] = 0;\n          this.data[location+i*4 + 1] = rgb.blue;\n          this.data[location+i*4 + 2] = rgb.green;\n          this.data[location+i*4 + 3] = rgb.red;\n\n        }else{\n          break;\n        }\n      }\n    }\n\n    if (mode != 0){\n      this.pos+=(4 - mode);\n    }\n  }\n};\n\nBmpDecoder.prototype.bit4 = function() {\n    //RLE-4\n    if(this.compress == 2){\n        this.data.fill(0xff);\n\n        var location = 0;\n        var lines = this.bottom_up?this.height-1:0;\n        var low_nibble = false;//for all count of pixel\n\n        while(location<this.data.length){\n            var a = this.buffer.readUInt8(this.pos++);\n            var b = this.buffer.readUInt8(this.pos++);\n            //absolute mode\n            if(a == 0){\n                if(b == 0){//line end\n                    if(this.bottom_up){\n                        lines--;\n                    }else{\n                        lines++;\n                    }\n                    location = lines*this.width*4;\n                    low_nibble = false;\n                    continue;\n                }else if(b == 1){//image end\n                    break;\n                }else if(b ==2){\n                    //offset x,y\n                    var x = this.buffer.readUInt8(this.pos++);\n                    var y = this.buffer.readUInt8(this.pos++);\n                    if(this.bottom_up){\n                        lines-=y;\n                    }else{\n                        lines+=y;\n                    }\n\n                    location +=(y*this.width*4+x*4);\n                }else{\n                    var c = this.buffer.readUInt8(this.pos++);\n                    for(var i=0;i<b;i++){\n                        if (low_nibble) {\n                            setPixelData.call(this, (c & 0x0f));\n                        } else {\n                            setPixelData.call(this, (c & 0xf0)>>4);\n                        }\n\n                        if ((i & 1) && (i+1 < b)){\n                            c = this.buffer.readUInt8(this.pos++);\n                        }\n\n                        low_nibble = !low_nibble;\n                    }\n\n                    if ((((b+1) >> 1) & 1 ) == 1){\n                        this.pos++\n                    }\n                }\n\n            }else{//encoded mode\n                for (var i = 0; i < a; i++) {\n                    if (low_nibble) {\n                        setPixelData.call(this, (b & 0x0f));\n                    } else {\n                        setPixelData.call(this, (b & 0xf0)>>4);\n                    }\n                    low_nibble = !low_nibble;\n                }\n            }\n\n        }\n\n\n\n\n        function setPixelData(rgbIndex){\n            var rgb = this.palette[rgbIndex];\n            this.data[location] = 0;\n            this.data[location + 1] = rgb.blue;\n            this.data[location + 2] = rgb.green;\n            this.data[location + 3] = rgb.red;\n            location+=4;\n        }\n    }else{\n\n      var xlen = Math.ceil(this.width/2);\n      var mode = xlen%4;\n      for (var y = this.height - 1; y >= 0; y--) {\n        var line = this.bottom_up ? y : this.height - 1 - y\n        for (var x = 0; x < xlen; x++) {\n          var b = this.buffer.readUInt8(this.pos++);\n          var location = line * this.width * 4 + x*2*4;\n\n          var before = b>>4;\n          var after = b&0x0F;\n\n          var rgb = this.palette[before];\n          this.data[location] = 0;\n          this.data[location + 1] = rgb.blue;\n          this.data[location + 2] = rgb.green;\n          this.data[location + 3] = rgb.red;\n\n\n          if(x*2+1>=this.width)break;\n\n          rgb = this.palette[after];\n\n          this.data[location+4] = 0;\n          this.data[location+4 + 1] = rgb.blue;\n          this.data[location+4 + 2] = rgb.green;\n          this.data[location+4 + 3] = rgb.red;\n\n        }\n\n        if (mode != 0){\n          this.pos+=(4 - mode);\n        }\n      }\n\n    }\n\n};\n\nBmpDecoder.prototype.bit8 = function() {\n    //RLE-8\n    if(this.compress == 1){\n        this.data.fill(0xff);\n\n        var location = 0;\n        var lines = this.bottom_up?this.height-1:0;\n\n        while(location<this.data.length){\n            var a = this.buffer.readUInt8(this.pos++);\n            var b = this.buffer.readUInt8(this.pos++);\n            //absolute mode\n            if(a == 0){\n                if(b == 0){//line end\n                    if(this.bottom_up){\n                        lines--;\n                    }else{\n                        lines++;\n                    }\n                    location = lines*this.width*4;\n                    continue;\n                }else if(b == 1){//image end\n                    break;\n                }else if(b ==2){\n                    //offset x,y\n                    var x = this.buffer.readUInt8(this.pos++);\n                    var y = this.buffer.readUInt8(this.pos++);\n                    if(this.bottom_up){\n                        lines-=y;\n                    }else{\n                        lines+=y;\n                    }\n\n                    location +=(y*this.width*4+x*4);\n                }else{\n                    for(var i=0;i<b;i++){\n                        var c = this.buffer.readUInt8(this.pos++);\n                        setPixelData.call(this, c);\n                    }\n                    if(b&1 == 1){\n                        this.pos++;\n                    }\n\n                }\n\n            }else{//encoded mode\n                for (var i = 0; i < a; i++) {\n                    setPixelData.call(this, b);\n                }\n            }\n\n        }\n\n\n\n\n        function setPixelData(rgbIndex){\n            var rgb = this.palette[rgbIndex];\n            this.data[location] = 0;\n            this.data[location + 1] = rgb.blue;\n            this.data[location + 2] = rgb.green;\n            this.data[location + 3] = rgb.red;\n            location+=4;\n        }\n    }else {\n        var mode = this.width % 4;\n        for (var y = this.height - 1; y >= 0; y--) {\n            var line = this.bottom_up ? y : this.height - 1 - y\n            for (var x = 0; x < this.width; x++) {\n                var b = this.buffer.readUInt8(this.pos++);\n                var location = line * this.width * 4 + x * 4;\n                if (b < this.palette.length) {\n                    var rgb = this.palette[b];\n\n                    this.data[location] = 0;\n                    this.data[location + 1] = rgb.blue;\n                    this.data[location + 2] = rgb.green;\n                    this.data[location + 3] = rgb.red;\n\n                } else {\n                    this.data[location] = 0;\n                    this.data[location + 1] = 0xFF;\n                    this.data[location + 2] = 0xFF;\n                    this.data[location + 3] = 0xFF;\n                }\n            }\n            if (mode != 0) {\n                this.pos += (4 - mode);\n            }\n        }\n    }\n};\n\nBmpDecoder.prototype.bit15 = function() {\n  var dif_w =this.width % 3;\n  var _11111 = parseInt(\"11111\", 2),_1_5 = _11111;\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y\n    for (var x = 0; x < this.width; x++) {\n\n      var B = this.buffer.readUInt16LE(this.pos);\n      this.pos+=2;\n      var blue = (B & _1_5) / _1_5 * 255 | 0;\n      var green = (B >> 5 & _1_5 ) / _1_5 * 255 | 0;\n      var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;\n      var alpha = (B>>15)?0xFF:0x00;\n\n      var location = line * this.width * 4 + x * 4;\n\n      this.data[location] = alpha;\n      this.data[location + 1] = blue;\n      this.data[location + 2] = green;\n      this.data[location + 3] = red;\n    }\n    //skip extra bytes\n    this.pos += dif_w;\n  }\n};\n\nBmpDecoder.prototype.bit16 = function() {\n  var dif_w =(this.width % 2)*2;\n  //default xrgb555\n  this.maskRed = 0x7C00;\n  this.maskGreen = 0x3E0;\n  this.maskBlue =0x1F;\n  this.mask0 = 0;\n\n  if(this.compress == 3){\n    this.maskRed = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n    this.maskGreen = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n    this.maskBlue = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n    this.mask0 = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n  }\n\n\n  var ns=[0,0,0];\n  for (var i=0;i<16;i++){\n    if ((this.maskRed>>i)&0x01) ns[0]++;\n    if ((this.maskGreen>>i)&0x01) ns[1]++;\n    if ((this.maskBlue>>i)&0x01) ns[2]++;\n  }\n  ns[1]+=ns[0]; ns[2]+=ns[1];\tns[0]=8-ns[0]; ns[1]-=8; ns[2]-=8;\n\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y;\n    for (var x = 0; x < this.width; x++) {\n\n      var B = this.buffer.readUInt16LE(this.pos);\n      this.pos+=2;\n\n      var blue = (B&this.maskBlue)<<ns[0];\n      var green = (B&this.maskGreen)>>ns[1];\n      var red = (B&this.maskRed)>>ns[2];\n\n      var location = line * this.width * 4 + x * 4;\n\n      this.data[location] = 0;\n      this.data[location + 1] = blue;\n      this.data[location + 2] = green;\n      this.data[location + 3] = red;\n    }\n    //skip extra bytes\n    this.pos += dif_w;\n  }\n};\n\nBmpDecoder.prototype.bit24 = function() {\n  for (var y = this.height - 1; y >= 0; y--) {\n    var line = this.bottom_up ? y : this.height - 1 - y\n    for (var x = 0; x < this.width; x++) {\n      //Little Endian rgb\n      var blue = this.buffer.readUInt8(this.pos++);\n      var green = this.buffer.readUInt8(this.pos++);\n      var red = this.buffer.readUInt8(this.pos++);\n      var location = line * this.width * 4 + x * 4;\n      this.data[location] = 0;\n      this.data[location + 1] = blue;\n      this.data[location + 2] = green;\n      this.data[location + 3] = red;\n    }\n    //skip extra bytes\n    this.pos += (this.width % 4);\n  }\n\n};\n\n/**\n * add 32bit decode func\n * @author soubok\n */\nBmpDecoder.prototype.bit32 = function() {\n  //BI_BITFIELDS\n  if(this.compress == 3){\n    this.maskRed = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n    this.maskGreen = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n    this.maskBlue = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n    this.mask0 = this.buffer.readUInt32LE(this.pos);\n    this.pos+=4;\n      for (var y = this.height - 1; y >= 0; y--) {\n          var line = this.bottom_up ? y : this.height - 1 - y;\n          for (var x = 0; x < this.width; x++) {\n              //Little Endian rgba\n              var alpha = this.buffer.readUInt8(this.pos++);\n              var blue = this.buffer.readUInt8(this.pos++);\n              var green = this.buffer.readUInt8(this.pos++);\n              var red = this.buffer.readUInt8(this.pos++);\n              var location = line * this.width * 4 + x * 4;\n              this.data[location] = alpha;\n              this.data[location + 1] = blue;\n              this.data[location + 2] = green;\n              this.data[location + 3] = red;\n          }\n      }\n\n  }else{\n      for (var y = this.height - 1; y >= 0; y--) {\n          var line = this.bottom_up ? y : this.height - 1 - y;\n          for (var x = 0; x < this.width; x++) {\n              //Little Endian argb\n              var blue = this.buffer.readUInt8(this.pos++);\n              var green = this.buffer.readUInt8(this.pos++);\n              var red = this.buffer.readUInt8(this.pos++);\n              var alpha = this.buffer.readUInt8(this.pos++);\n              var location = line * this.width * 4 + x * 4;\n              this.data[location] = alpha;\n              this.data[location + 1] = blue;\n              this.data[location + 2] = green;\n              this.data[location + 3] = red;\n          }\n      }\n\n  }\n\n\n\n\n};\n\nBmpDecoder.prototype.getData = function() {\n  return this.data;\n};\n\nmodule.exports = function(bmpData) {\n  var decoder = new BmpDecoder(bmpData);\n  return decoder;\n};\n"]}